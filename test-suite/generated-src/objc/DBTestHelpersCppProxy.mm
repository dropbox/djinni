// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from test.djinni

#import "DBTestHelpersCppProxy+Private.h"
#import "DBAssortedIntegers+Private.h"
#import "DBClientInterfaceObjcProxy+Private.h"
#import "DBColor.h"
#import "DBColorTranslator+Private.h"
#import "DBMapListRecord+Private.h"
#import "DBNestedCollection+Private.h"
#import "DBPrimitiveList+Private.h"
#import "DBSetRecord+Private.h"
#import "DBTestHelpers.h"
#import "DBTokenCppProxy+Private.h"
#import "DJIError.h"
#include <exception>
#include <utility>

static_assert(__has_feature(objc_arc), "Djinni requires ARC to be enabled for this file");

@implementation DBTestHelpersCppProxy

- (id)initWithCpp:(const std::shared_ptr<::djinni::cpp::TestHelpers> &)cppRef
{
    if (self = [super init]) {
        _cppRef = cppRef;
    }
    return self;
}

- (void)dealloc
{
    djinni::DbxCppWrapperCache<::djinni::cpp::TestHelpers> & cache = djinni::DbxCppWrapperCache<::djinni::cpp::TestHelpers>::getInstance();
    cache.remove(_cppRef);
}

+ (id)testHelpersWithCpp:(const std::shared_ptr<::djinni::cpp::TestHelpers> &)cppRef
{
    djinni::DbxCppWrapperCache<::djinni::cpp::TestHelpers> & cache = djinni::DbxCppWrapperCache<::djinni::cpp::TestHelpers>::getInstance();
    return cache.get(cppRef, [] (const std::shared_ptr<::djinni::cpp::TestHelpers> & p) { return [[DBTestHelpersCppProxy alloc] initWithCpp:p]; });
}

+ (DBSetRecord *)getSetRecord {
    try {
        ::djinni::cpp::SetRecord cppRet = ::djinni::cpp::TestHelpers::get_set_record();
        DBSetRecord *objcRet = [[DBSetRecord alloc] initWithCppSetRecord:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (BOOL)checkSetRecord:(DBSetRecord *)rec {
    try {
        ::djinni::cpp::SetRecord cppRec = std::move([rec cppSetRecord]);
        bool cppRet = ::djinni::cpp::TestHelpers::check_set_record(std::move(cppRec));
        BOOL objcRet = (cppRet) ? YES : NO;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (DBPrimitiveList *)getPrimitiveList {
    try {
        ::djinni::cpp::PrimitiveList cppRet = ::djinni::cpp::TestHelpers::get_primitive_list();
        DBPrimitiveList *objcRet = [[DBPrimitiveList alloc] initWithCppPrimitiveList:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (BOOL)checkPrimitiveList:(DBPrimitiveList *)pl {
    try {
        ::djinni::cpp::PrimitiveList cppPl = std::move([pl cppPrimitiveList]);
        bool cppRet = ::djinni::cpp::TestHelpers::check_primitive_list(std::move(cppPl));
        BOOL objcRet = (cppRet) ? YES : NO;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (DBNestedCollection *)getNestedCollection {
    try {
        ::djinni::cpp::NestedCollection cppRet = ::djinni::cpp::TestHelpers::get_nested_collection();
        DBNestedCollection *objcRet = [[DBNestedCollection alloc] initWithCppNestedCollection:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (BOOL)checkNestedCollection:(DBNestedCollection *)nc {
    try {
        ::djinni::cpp::NestedCollection cppNc = std::move([nc cppNestedCollection]);
        bool cppRet = ::djinni::cpp::TestHelpers::check_nested_collection(std::move(cppNc));
        BOOL objcRet = (cppRet) ? YES : NO;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (NSMutableDictionary *)getMap {
    try {
        std::unordered_map<std::string, int64_t> cppRet = ::djinni::cpp::TestHelpers::get_map();
        NSMutableDictionary *objcRet = [NSMutableDictionary dictionaryWithCapacity:cppRet.size()];
        for (const auto & cppPair_0 : cppRet) {
            NSString *objcKey_0 = [[NSString alloc] initWithBytes:cppPair_0.first.data()
                    length:cppPair_0.first.length()
                    encoding:NSUTF8StringEncoding];
            NSNumber *objcValue_0 = [NSNumber numberWithLongLong:cppPair_0.second];
            [objcRet setObject:objcValue_0 forKey:objcKey_0];
        }
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (BOOL)checkMap:(NSMutableDictionary *)m {
    try {
        std::unordered_map<std::string, int64_t> cppM;
        for (id objcKey_0 in m) {
            std::string cppKey_0([objcKey_0 UTF8String], [objcKey_0 lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
            int64_t cppValue_0 = [[m objectForKey:objcKey_0] longLongValue];
            cppM.emplace(std::move(cppKey_0), std::move(cppValue_0));
        }
        bool cppRet = ::djinni::cpp::TestHelpers::check_map(std::move(cppM));
        BOOL objcRet = (cppRet) ? YES : NO;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (NSMutableDictionary *)getEmptyMap {
    try {
        std::unordered_map<std::string, int64_t> cppRet = ::djinni::cpp::TestHelpers::get_empty_map();
        NSMutableDictionary *objcRet = [NSMutableDictionary dictionaryWithCapacity:cppRet.size()];
        for (const auto & cppPair_0 : cppRet) {
            NSString *objcKey_0 = [[NSString alloc] initWithBytes:cppPair_0.first.data()
                    length:cppPair_0.first.length()
                    encoding:NSUTF8StringEncoding];
            NSNumber *objcValue_0 = [NSNumber numberWithLongLong:cppPair_0.second];
            [objcRet setObject:objcValue_0 forKey:objcKey_0];
        }
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (BOOL)checkEmptyMap:(NSMutableDictionary *)m {
    try {
        std::unordered_map<std::string, int64_t> cppM;
        for (id objcKey_0 in m) {
            std::string cppKey_0([objcKey_0 UTF8String], [objcKey_0 lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
            int64_t cppValue_0 = [[m objectForKey:objcKey_0] longLongValue];
            cppM.emplace(std::move(cppKey_0), std::move(cppValue_0));
        }
        bool cppRet = ::djinni::cpp::TestHelpers::check_empty_map(std::move(cppM));
        BOOL objcRet = (cppRet) ? YES : NO;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (DBMapListRecord *)getMapListRecord {
    try {
        ::djinni::cpp::MapListRecord cppRet = ::djinni::cpp::TestHelpers::get_map_list_record();
        DBMapListRecord *objcRet = [[DBMapListRecord alloc] initWithCppMapListRecord:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (BOOL)checkMapListRecord:(DBMapListRecord *)m {
    try {
        ::djinni::cpp::MapListRecord cppM = std::move([m cppMapListRecord]);
        bool cppRet = ::djinni::cpp::TestHelpers::check_map_list_record(std::move(cppM));
        BOOL objcRet = (cppRet) ? YES : NO;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (void)checkClientInterfaceAscii:(id <DBClientInterface>)i {
    try {
        std::shared_ptr<::djinni::cpp::ClientInterface> cppI = ::djinni_generated::ClientInterfaceObjcProxy::client_interface_with_objc(i);
        ::djinni::cpp::TestHelpers::check_client_interface_ascii(std::move(cppI));
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (void)checkClientInterfaceNonascii:(id <DBClientInterface>)i {
    try {
        std::shared_ptr<::djinni::cpp::ClientInterface> cppI = ::djinni_generated::ClientInterfaceObjcProxy::client_interface_with_objc(i);
        ::djinni::cpp::TestHelpers::check_client_interface_nonascii(std::move(cppI));
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (void)checkEnumMap:(NSMutableDictionary *)m {
    try {
        std::unordered_map<::djinni::cpp::color, std::string> cppM;
        for (id objcKey_0 in m) {
            ::djinni::cpp::color cppKey_0 = [DBColorTranslator objcColorToCppColor:(DBColor)[objcKey_0 intValue]];
            std::string cppValue_0([[m objectForKey:objcKey_0] UTF8String], [[m objectForKey:objcKey_0] lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
            cppM.emplace(std::move(cppKey_0), std::move(cppValue_0));
        }
        ::djinni::cpp::TestHelpers::check_enum_map(std::move(cppM));
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (id <DBToken>)tokenId:(id <DBToken>)t {
    try {
        std::shared_ptr<::djinni::cpp::Token> cppT = [(DBTokenCppProxy *)t cppRef];
        std::shared_ptr<::djinni::cpp::Token> cppRet = ::djinni::cpp::TestHelpers::token_id(std::move(cppT));
        id <DBToken> objcRet = [DBTokenCppProxy tokenWithCpp:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (id <DBToken>)createCppToken {
    try {
        std::shared_ptr<::djinni::cpp::Token> cppRet = ::djinni::cpp::TestHelpers::create_cpp_token();
        id <DBToken> objcRet = [DBTokenCppProxy tokenWithCpp:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (void)checkCppToken:(id <DBToken>)t {
    try {
        std::shared_ptr<::djinni::cpp::Token> cppT = [(DBTokenCppProxy *)t cppRef];
        ::djinni::cpp::TestHelpers::check_cpp_token(std::move(cppT));
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (int64_t)cppTokenId:(id <DBToken>)t {
    try {
        std::shared_ptr<::djinni::cpp::Token> cppT = [(DBTokenCppProxy *)t cppRef];
        int64_t cppRet = ::djinni::cpp::TestHelpers::cpp_token_id(std::move(cppT));
        int64_t objcRet = cppRet;
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (NSNumber *)returnNone {
    try {
        std::experimental::optional<int32_t> cppRet = ::djinni::cpp::TestHelpers::return_none();
        NSNumber *objcRet;
        if (cppRet) {
            objcRet = [NSNumber numberWithInt:(*(cppRet))];
        } else {
            objcRet = nil;
        }
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

+ (DBAssortedIntegers *)assortedIntegersId:(DBAssortedIntegers *)i {
    try {
        ::djinni::cpp::AssortedIntegers cppI = std::move([i cppAssortedIntegers]);
        ::djinni::cpp::AssortedIntegers cppRet = ::djinni::cpp::TestHelpers::assorted_integers_id(std::move(cppI));
        DBAssortedIntegers *objcRet = [[DBAssortedIntegers alloc] initWithCppAssortedIntegers:cppRet];
        return objcRet;
    } DJINNI_TRANSLATE_EXCEPTIONS()
}

@end
