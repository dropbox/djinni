// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from enum_flags.djinni

#pragma once

#include <functional>

namespace testsuite {

enum class empty_flags : unsigned {
    NONE = 0,
    ALL = 0,
};
constexpr empty_flags operator|(empty_flags lhs, empty_flags rhs) noexcept {
    return static_cast<empty_flags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs));
}
inline empty_flags& operator|=(empty_flags& lhs, empty_flags rhs) noexcept {
    return lhs = lhs | rhs;
}
constexpr empty_flags operator&(empty_flags lhs, empty_flags rhs) noexcept {
    return static_cast<empty_flags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs));
}
inline empty_flags& operator&=(empty_flags& lhs, empty_flags rhs) noexcept {
    return lhs = lhs & rhs;
}
constexpr empty_flags operator^(empty_flags lhs, empty_flags rhs) noexcept {
    return static_cast<empty_flags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs));
}
inline empty_flags& operator^=(empty_flags& lhs, empty_flags rhs) noexcept {
    return lhs = lhs ^ rhs;
}
constexpr empty_flags operator~(empty_flags x) noexcept {
    return static_cast<empty_flags>(~static_cast<unsigned>(x));
}

}  // namespace testsuite

namespace std {

template <>
struct hash<::testsuite::empty_flags> {
    size_t operator()(::testsuite::empty_flags type) const {
        return std::hash<unsigned>()(static_cast<unsigned>(type));
    }
};
template <>
class numeric_limits<::testsuite::empty_flags> : public numeric_limits<unsigned> {
    public:
    static constexpr bool is_specialized = true;
    static constexpr ::testsuite::empty_flags max() noexcept { return static_cast<::testsuite::empty_flags>(0); }
};

}  // namespace std
