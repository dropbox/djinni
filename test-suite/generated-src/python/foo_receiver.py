# AUTOGENERATED FILE - DO NOT MODIFY!
# This file generated by Djinni from foo_receiver.djinni

from djinni.support import MultiSet # default imported in all files
from djinni.exception import CPyException # default imported in all files
from djinni.pycffi_marshal import CPyBinary, CPyBoxedI32, CPyDate, CPyPrimitive, CPyRecord, CPyString

from abc import ABCMeta, abstractmethod
from foo_listener import FooListener
from foo_listener import FooListenerHelper
from foo_listener_bf import FooListenerBf
from foo_listener_bf import FooListenerBfHelper
from foo_some_other_record import FooSomeOtherRecord
from foo_some_other_record_helper import FooSomeOtherRecordHelper
from future.utils import with_metaclass
from PyCFFIlib_cffi import ffi, lib

from djinni import exception # this forces run of __init__.py which gives cpp option to call back into py to create exception

class FooReceiver(with_metaclass(ABCMeta)):
    @abstractmethod
    def set_private_string(self, private_string):
        raise NotImplementedError

    @abstractmethod
    def get_private_string(self):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_string_returned(self, i, f, s, binar, b, d):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_binary_returned(self, i, f, s, binar, b, d):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_date_returned(self, i, f, s, binar, b, d):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_int_returned(self, i, f, s, binar, b, d):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_record_returned(self, n1, n2):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_string_optional_returned(self, i, f, s, binar, b, d):
        raise NotImplementedError

    @abstractmethod
    def cause_changes_int_optional_returned(self, i, f, s, binar, b, d):
        raise NotImplementedError

    @abstractmethod
    def cause_cpp_exception(self, exception_arg):
        raise NotImplementedError

    @abstractmethod
    def cause_py_exception(self, exception_arg):
        raise NotImplementedError

    @abstractmethod
    def cause_zero_division_error(self):
        raise NotImplementedError

    @abstractmethod
    def add_listener(self, listener):
        raise NotImplementedError

    @abstractmethod
    def add_optional_listener(self, listener):
        raise NotImplementedError

    @abstractmethod
    def get_optional_listener(self):
        raise NotImplementedError

    @abstractmethod
    def set_private_bf_string(self, private_string):
        """ For testing proxying during bidirectional callbacks """
        raise NotImplementedError

    @abstractmethod
    def add_listener_bf(self, listener):
        raise NotImplementedError

    @abstractmethod
    def get_foo_listener_bf(self):
        raise NotImplementedError

    @abstractmethod
    def get_listener_bf_string(self):
        raise NotImplementedError

    @abstractmethod
    def set_listener_bf_in_listener_bf(self, listener):
        raise NotImplementedError

    @abstractmethod
    def get_listener_bf_in_listener_bf(self):
        raise NotImplementedError

    @abstractmethod
    def set_binary_in_listener_bf_in_listener_bf(self, b):
        raise NotImplementedError

    @abstractmethod
    def get_binary_in_listener_bf_in_listener_bf(self):
        raise NotImplementedError

    @abstractmethod
    def send_return(self, fl_bf):
        raise NotImplementedError

    @abstractmethod
    def in_listener_bf_send_return(self, fl_bf):
        raise NotImplementedError

    @staticmethod
    def create():
        return FooReceiverCppProxy.create()

class FooReceiverCppProxy(FooReceiver):
    def __init__(self, proxy):
        self._is_cpp_proxy = True
        self._cpp_impl = proxy
    def __del__(self):
        if not lib:
            return
        lib.foo_receiver___wrapper_dec_ref(self._cpp_impl)

    def set_private_string(self, private_string):
        with CPyString.fromPy(private_string) as pys_private_string:
            _ret_c = lib.cw__foo_receiver_set_private_string(self._cpp_impl, pys_private_string.release_djinni_string())
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyString.toPy(_ret_c)
            assert _ret is not None
            return _ret

    def get_private_string(self):
        _ret_c = lib.cw__foo_receiver_get_private_string(self._cpp_impl)
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = CPyString.toPy(_ret_c)
        assert _ret is not None
        return _ret

    def cause_changes_string_returned(self, i, f, s, binar, b, d):
        with CPyString.fromPy(s) as pys_s,\
                CPyBinary.fromPy(binar) as pybin_binar:
            _ret_c = lib.cw__foo_receiver_cause_changes_string_returned(self._cpp_impl, CPyPrimitive.fromPy(i), CPyPrimitive.fromPy(f), pys_s.release_djinni_string(), pybin_binar.release_djinni_binary(), CPyPrimitive.fromPy(b), CPyDate.fromPy(d))
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyString.toPy(_ret_c)
            assert _ret is not None
            return _ret

    def cause_changes_binary_returned(self, i, f, s, binar, b, d):
        with CPyString.fromPy(s) as pys_s,\
                CPyBinary.fromPy(binar) as pybin_binar:
            _ret_c = lib.cw__foo_receiver_cause_changes_binary_returned(self._cpp_impl, CPyPrimitive.fromPy(i), CPyPrimitive.fromPy(f), pys_s.release_djinni_string(), pybin_binar.release_djinni_binary(), CPyPrimitive.fromPy(b), CPyDate.fromPy(d))
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyBinary.toPy(_ret_c)
            assert _ret is not None
            return _ret

    def cause_changes_date_returned(self, i, f, s, binar, b, d):
        with CPyString.fromPy(s) as pys_s,\
                CPyBinary.fromPy(binar) as pybin_binar:
            _ret_c = lib.cw__foo_receiver_cause_changes_date_returned(self._cpp_impl, CPyPrimitive.fromPy(i), CPyPrimitive.fromPy(f), pys_s.release_djinni_string(), pybin_binar.release_djinni_binary(), CPyPrimitive.fromPy(b), CPyDate.fromPy(d))
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyDate.toPy(_ret_c)
            assert _ret is not None
            return _ret

    def cause_changes_int_returned(self, i, f, s, binar, b, d):
        with CPyString.fromPy(s) as pys_s,\
                CPyBinary.fromPy(binar) as pybin_binar:
            _ret_c = lib.cw__foo_receiver_cause_changes_int_returned(self._cpp_impl, CPyPrimitive.fromPy(i), CPyPrimitive.fromPy(f), pys_s.release_djinni_string(), pybin_binar.release_djinni_binary(), CPyPrimitive.fromPy(b), CPyDate.fromPy(d))
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyPrimitive.toPy(_ret_c)
            assert _ret is not None
            return _ret

    def cause_changes_record_returned(self, n1, n2):
        _ret_c = lib.cw__foo_receiver_cause_changes_record_returned(self._cpp_impl, CPyPrimitive.fromPy(n1), CPyPrimitive.fromPy(n2))
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = CPyRecord.toPy(FooSomeOtherRecord.c_data_set, _ret_c)
        assert _ret is not None
        return _ret

    def cause_changes_string_optional_returned(self, i, f, s, binar, b, d):
        with CPyBoxedI32.fromPyOpt(i) as pyopt_i,\
                CPyString.fromPyOpt(s) as pyopt_s,\
                CPyBinary.fromPy(binar) as pybin_binar:
            _ret_c = lib.cw__foo_receiver_cause_changes_string_optional_returned(self._cpp_impl, pyopt_i.release_djinni_boxed(), CPyPrimitive.fromPy(f), pyopt_s.release_djinni_string(), pybin_binar.release_djinni_binary(), CPyPrimitive.fromPy(b), CPyDate.fromPy(d))
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyString.toPyOpt(_ret_c)
            return _ret

    def cause_changes_int_optional_returned(self, i, f, s, binar, b, d):
        with CPyBoxedI32.fromPyOpt(i) as pyopt_i,\
                CPyString.fromPyOpt(s) as pyopt_s,\
                CPyBinary.fromPy(binar) as pybin_binar:
            _ret_c = lib.cw__foo_receiver_cause_changes_int_optional_returned(self._cpp_impl, pyopt_i.release_djinni_boxed(), CPyPrimitive.fromPy(f), pyopt_s.release_djinni_string(), pybin_binar.release_djinni_binary(), CPyPrimitive.fromPy(b), CPyDate.fromPy(d))
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyBoxedI32.toPyOpt(_ret_c)
            return _ret

    def cause_cpp_exception(self, exception_arg):
        with CPyString.fromPy(exception_arg) as pys_exception_arg:
            lib.cw__foo_receiver_cause_cpp_exception(self._cpp_impl, pys_exception_arg.release_djinni_string())
            CPyException.toPyCheckAndRaise(ffi.NULL)

    def cause_py_exception(self, exception_arg):
        with CPyString.fromPy(exception_arg) as pys_exception_arg:
            lib.cw__foo_receiver_cause_py_exception(self._cpp_impl, pys_exception_arg.release_djinni_string())
            CPyException.toPyCheckAndRaise(ffi.NULL)

    def cause_zero_division_error(self):
        lib.cw__foo_receiver_cause_zero_division_error(self._cpp_impl)
        CPyException.toPyCheckAndRaise(ffi.NULL)

    def add_listener(self, listener):
        lib.cw__foo_receiver_add_listener(self._cpp_impl, FooListenerHelper.fromPy(listener))
        CPyException.toPyCheckAndRaise(ffi.NULL)

    def add_optional_listener(self, listener):
        lib.cw__foo_receiver_add_optional_listener(self._cpp_impl, FooListenerHelper.fromPy(listener))
        CPyException.toPyCheckAndRaise(ffi.NULL)

    def get_optional_listener(self):
        _ret_c = lib.cw__foo_receiver_get_optional_listener(self._cpp_impl)
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = FooListenerHelper.toPy(_ret_c)
        return _ret

    def set_private_bf_string(self, private_string):
        with CPyString.fromPy(private_string) as pys_private_string:
            _ret_c = lib.cw__foo_receiver_set_private_bf_string(self._cpp_impl, pys_private_string.release_djinni_string())
            CPyException.toPyCheckAndRaise(_ret_c)
            _ret = CPyString.toPy(_ret_c)
            assert _ret is not None
            return _ret

    def add_listener_bf(self, listener):
        lib.cw__foo_receiver_add_listener_bf(self._cpp_impl, FooListenerBfHelper.fromPy(listener))
        CPyException.toPyCheckAndRaise(ffi.NULL)

    def get_foo_listener_bf(self):
        _ret_c = lib.cw__foo_receiver_get_foo_listener_bf(self._cpp_impl)
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = FooListenerBfHelper.toPy(_ret_c)
        assert _ret is not None
        return _ret

    def get_listener_bf_string(self):
        _ret_c = lib.cw__foo_receiver_get_listener_bf_string(self._cpp_impl)
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = CPyString.toPy(_ret_c)
        assert _ret is not None
        return _ret

    def set_listener_bf_in_listener_bf(self, listener):
        lib.cw__foo_receiver_set_listener_bf_in_listener_bf(self._cpp_impl, FooListenerBfHelper.fromPy(listener))
        CPyException.toPyCheckAndRaise(ffi.NULL)

    def get_listener_bf_in_listener_bf(self):
        _ret_c = lib.cw__foo_receiver_get_listener_bf_in_listener_bf(self._cpp_impl)
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = FooListenerBfHelper.toPy(_ret_c)
        assert _ret is not None
        return _ret

    def set_binary_in_listener_bf_in_listener_bf(self, b):
        with CPyBinary.fromPy(b) as pybin_b:
            lib.cw__foo_receiver_set_binary_in_listener_bf_in_listener_bf(self._cpp_impl, pybin_b.release_djinni_binary())
            CPyException.toPyCheckAndRaise(ffi.NULL)

    def get_binary_in_listener_bf_in_listener_bf(self):
        _ret_c = lib.cw__foo_receiver_get_binary_in_listener_bf_in_listener_bf(self._cpp_impl)
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = CPyBinary.toPy(_ret_c)
        assert _ret is not None
        return _ret

    def send_return(self, fl_bf):
        _ret_c = lib.cw__foo_receiver_send_return(self._cpp_impl, FooListenerBfHelper.fromPy(fl_bf))
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = FooListenerBfHelper.toPy(_ret_c)
        assert _ret is not None
        return _ret

    def in_listener_bf_send_return(self, fl_bf):
        _ret_c = lib.cw__foo_receiver_in_listener_bf_send_return(self._cpp_impl, FooListenerBfHelper.fromPy(fl_bf))
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = FooListenerBfHelper.toPy(_ret_c)
        assert _ret is not None
        return _ret

    @staticmethod
    def create():
        _ret_c = lib.cw__foo_receiver_create()
        CPyException.toPyCheckAndRaise(_ret_c)
        _ret = FooReceiverHelper.toPy(_ret_c)
        assert _ret is not None
        return _ret

class FooReceiverHelper:
    c_data_set = MultiSet()
    @staticmethod
    def toPy(obj):
        if obj == ffi.NULL:
            return None
        return FooReceiverCppProxy(obj)

