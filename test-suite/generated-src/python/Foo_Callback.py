# AUTOGENERATED FILE - DO NOT MODIFY!
# This file generated by Djinni from foo_duplicate_file_creation.djinni

from djinni.support import MultiSet # default imported in all files
from djinni.exception import CPyException # default imported in all files
from djinni.pycffi_marshal import CPyObject, CPyRecord

from Foo_Record import FooRecord
from Foo_Record_helper import FooRecordHelper
from abc import ABCMeta, abstractmethod
from dh__list_record_Foo_Record import ListRecordFooRecordHelper
from future.utils import with_metaclass
from PyCFFIlib_cffi import ffi, lib

from djinni import exception # this forces run of __init__.py which gives cpp option to call back into py to create exception

class FooCallback(with_metaclass(ABCMeta)):
    @abstractmethod
    def methodA(self, records):
        raise NotImplementedError

    @abstractmethod
    def methodB(self, records):
        raise NotImplementedError


class FooCallbackCppProxy(FooCallback):
    def __init__(self, proxy):
        self._is_cpp_proxy = True
        self._cpp_impl = proxy
    def __del__(self):
        if not lib:
            return
        lib.Foo_Callback___wrapper_dec_ref(self._cpp_impl)

    def methodA(self, records):
        lib.cw__Foo_Callback_methodA(self._cpp_impl, CPyObject.fromPy(ListRecordFooRecordHelper.c_data_set, records))
        CPyException.toPyCheckAndRaise(ffi.NULL)

    def methodB(self, records):
        lib.cw__Foo_Callback_methodB(self._cpp_impl, CPyObject.fromPy(ListRecordFooRecordHelper.c_data_set, records))
        CPyException.toPyCheckAndRaise(ffi.NULL)

class FooCallbackHelper:
    c_data_set = MultiSet()
    @staticmethod
    def toPy(obj):
        if obj == ffi.NULL:
            return None
        return FooCallbackCppProxy(obj)

